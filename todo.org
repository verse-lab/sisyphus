* Limitations
** Invariants hidden in external lemmas
An example of such a case would be when we're dealing with a proof
style that first reifies an OCaml computation with a Gallina model,
and uses their equivalence as an invariant. Then once evaluating the
lemma, the proof calls out to an external lemma to reduce the proof.
* Tasks for the PROOF GOD
** DONE Create branch for array of rev list
CLOSED: [2022-09-28 Wed 03:13]
** DONE Rewrite array of rev list in terms of for loop combinator
CLOSED: [2022-09-28 Wed 03:35]
** DONE Prove correctness of for loop combinator
CLOSED: [2022-09-28 Wed 04:03]
** DONE Prove correctness of rev list using loop combinator
CLOSED: [2022-09-28 Wed 06:08]
** DONE Get benchmark running on array of rev list
CLOSED: [2022-09-28 Wed 06:15]
** DONE Fix issues with program structure of array of rev list 
CLOSED: [2022-09-28 Wed 06:18]
** TODO Handle proof parsing of array of rev list
** TODO Print out Z3 queries
** TODO Get to Proof term analysis or better w.r.t array of rev list
** TODO You're the BEST around

* Tasks for the proof demigod
** DONE Add array of rev list
CLOSED: [2022-09-27 Tue 16:35]
*** Make it build
** DONE Add benchmark test for array_of_rev list
CLOSED: [2022-09-27 Tue 17:02]
** TODO How to handle HO loops?
*** Add xfor and xwhile [1 hr]
*** Look through examples and find minimal set of combinators that capture all recursion
*** Rewrite array_of_rev_list using HO iterator
*** Define & prove specification for for-loop iterator (nat_fold_left)
*** Prove new program
** TODO Add modular tests
